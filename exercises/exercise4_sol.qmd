# W4 Exercises

```{r, warnings=F, message=F}
library(tidyverse)
library(palmerpenguins)
load(url("https://github.com/caalo/Intro_to_R/raw/main/classroom_data/CCLE.RData"))
```

## Part 1: Warm-up/a remark on subsetting vectors

Consider the following vector:

```{r}
age = c(10, 35, 24, 70, 84)
```

In one line of code, subset `age` to be greater than 65 and store it as `age_over_65`.

```{r}
age_over_65 = age[age > 65]
```

Another use of subsetting is to modify part of a vector that satisfy a particular criteria. Instead of having the bracket `[ ]` notation on the right hand side of the equation, if it is on the left hand side of the equation, then we can modify a subset of the vector.

To demonstrate it, let's create a new variable, `medicaid_eligible` so that it is identical as `age`.

```{r}
medicaid_eligible = age
```

We can modify `medicaid_eligible` so that all elements of `medicaid_eligible` that is less than 65 is assigned to a value of 1.

```{r}
medicaid_eligible[medicaid_eligible < 65] = 1
medicaid_eligible
```

Now, modify `medicaid_eligible` so that all elements of `medicaid_eligible` that is less than 65 is assigned to a value of 0.

```{r}
medicaid_eligible[medicaid_eligible < 65] = 0
```

## Part 2: Functions continued

Create a function, called `add_and_raise_power` in which the function takes in 3 numeric arguments. The function computes the following: the first two arguments are added together and raised to a power determined by the 3rd argument. The function returns the resulting value.

Use case: `add_and_raise_power(1, 2, 3) = 9` because the function will return this expression: `(1 + 2) ^ 3`.

Another use case: `add_and_raise_power(3, 1, 2) = 16`

```{r}
add_and_raise_power = function(num1, num2, num3) {
  result = (num1 + num2) ^ num3
  return(result)
}

add_and_raise_power(1, 2, 3)
```

We can use this function for numerics and numerical vectors. To use this function on numerical vectors, consider the following dataframe:

```{r}
simple_df = data.frame(id = c("AAA", "BBB", "CCC", "DDD", "EEE"),
                       case_control = c("case", "case", "control", "control", "control"),
                       measurement1 = c(2.5, 3.5, 9, .1, 2.2),
                       measurement2 = c(0, 0, .5, .24, .003),
                       measurement3 = c(80, 2, 1, 1, 2))

simple_df
```

Create a new column, named `result`, via `mutate` or `$`, which takes on the value of `add_and_raise_power` function result with input arguments `simple_df$measurement1`, `simple_df$measurement2`, and `simple_df$measurement3`.

```{r}
simple_df = mutate(simple_df, result = add_and_raise_power(measurement1, measurement2, measurement3))
```

Filter simple_df to samples that have "case" in `case_control` column, and look at the mean of the `result` column. Do the same for samples that have the "control" in `case_control` column. How do they compare? 

```{r}
case = simple_df %>% filter(case_control == "case")
mean(case$result)

control = simple_df %>% filter(case_control == "control")
mean(control$result)
```

## Part 3: Joining multiple dataframes

Using `full_join` twice, create a dataframe that has columns from `metadata`, `expression`, and `mutation`. How will you check your work to know that you did the join correctly?

```{r, message=FALSE}
metadata_expression = full_join(metadata, expression, by = "ModelID")
metadata_expression_mutation = full_join(metadata_expression, mutation, by = "ModelID")
```

## Part 4: group_by and summarise

Consider the `penguins` dataframe: use `group_by` and `summarise` to create a new dataframe so that each row represents one species (you should have a total of 3 rows in this dataframe). As for the columns, create a column `n_penguins` that gives us the number of penguins, a column `mean_bill_length_mm` that gives the mean bill length for each species (make sure you use `na.rm = TRUE` in the argument for the `mean` function).

```{r}
penguins_speceies = penguins %>% group_by(species) %>% summarise(n_penguins = n(), mean_bill_length_mm = mean(bill_length_mm, na.rm=T))
```
