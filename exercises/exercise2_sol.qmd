# W2 Exercises

If you need to clear your environment and start from the beginning, this code chunk will do that:

```{r}
rm(list = ls())
```

## Part 1: Comparison operators on data types

In class, we looked at comparison operators on vectors to create logical indexing vectors. We are going to first take a step back and see how comparison operators work on simpler data types. Here are the comparison operators common in R:

`<` less than

`<=` less or equal than

`==` equal to

`!=` not equal to

`>` greater than

`>=` greater than or equal to

Consider the following variables:

```{r}
chr1 = 2
chr2 = 3
chr3 = 1
staff1 = "chris"
staff2 = "shasta"
```

We saw how we used comparision operators on vectors, but they can be used for any singular data type:

Using comparison operators, write 3 expressions so that the returned value is `TRUE`. I'll give one example:

```{r}
staff1 != "jeff"
staff1 == "chris"
chr3 == 1
```

Using comparison operators, write 3 expressions so that the returned value is `FALSE`:

```{r}
chr1 > 2
chr3 == 0
chr3 > 1000

```

We can combine comparison operators together to form more complex statements:

The "and" `&` operator returns `TRUE` if both inputs have values of `TRUE`, and `FALSE` otherwise:

```{r}
a = TRUE
b = TRUE
c = FALSE
d = FALSE
a & b
c & d
a & c
b & d
```

Therefore, we can create compound comparison operations like this:

```{r}
chr1 > chr3 & chr1 < chr2
```

Similarly, the "or" `|` operator returns `TRUE` if at least one of the inputs are `TRUE`. Otherwise it returns `FALSE`.

Using `a`, `b`, `c`, `d` as before, apply them to the `|` operator and see what you get.

```{r}
a | b
c | d
a | c
b | d




```

Create 2 compound comparison operations using `|` so that one returns `TRUE` and the other returns `FALSE`. I'll give you one example:

```{r}
chr1 > chr3 | chr1 < chr2

```

You can extend these compound statements to contain multiple `&` and `|` operations mixed together, and parentheses should be used to clarify your order of operation.

**Now, let's use comparison operators on vectors.**

We create the `age` vector from our lesson.

```{r}
set.seed(123) #don't worry about this function
age = round(runif(100, 1, 100)) #don't worry about these functions
```

Create a compound comparison operation that looks returns a logical vector so that the elements are `TRUE` if `age` is between 18 and 65.

```{r}
age > 18 & age < 65
```

## Part 2: Subsetting vectors

Let's practice explicit subsetting. Can you subset for the first 20 elements of `age`?

```{r}
age[1:20]
```

Now, on to implicit subsetting. Can you subset for all `age` greater than 65?

```{r}
age[age > 65]
```

We will now look at subsetting using compound comparison operators: We will subset for ages between 18 and 22 in two ways:

Method 1: first, create a logical indexing vector via compound comparison operators that gives `TRUE` if `age` is between 18 and 22 and `FALSE` otherwise. You should use the `&` operator.

```{r}
vec = age > 18 & age < 22
```

Then, subset `age` by your indexing vector and store it as a new variable called `college_age`.

```{r}
college_age = age[vec]
```

Method 2: can you do all of this in one expression and store it as a variable called `college_age_also`? ie. write it so that you don't store your indexing vector as a variable in the environment. I have given a hint in the code comment below:

```{r}
#college_age_also = age[compound_comparision_operator_goes_here]

college_age_also = age[age > 18 & age < 22]
```

Check the lengths of `college_age` and `college_age_also`. Are they the same?

```{r}
length(college_age)
length(college_age_also)
```

Confirm that the elements of the two vectors are all identical by using the comparison operation `==` on `college_age` and `college_age_also`: type in `college_age == college_age_also`. What is the resulting data structure? Does it make sense to you? This is another example of **operator overloading**: we have seen how comparison operators work for single data types, how comparison operators work between vectors and a single data type, and now we see how comparison operators work for two vectors of the same length.

```{r}
college_age == college_age_also
```

What you have just done is to make sure that two slightly different method of computation resulted in the same vector of same length and values. This kind of validation as you try different ways to solve problems is fundamental to programming: we write testing code to make sure what we are programming is doing what we expect it to do.

We could alternatively use the function `identical()` checks for completely identical data structures:

```{r}
identical(college_age, college_age_also)
```

To think on your own: what is the advantage of using `identical()` to confirm that two expressions are giving us the same result? What are some disadvantages in which methods such as `college_age == college_age_also` is preferred?

## Part 3: Subsetting dataframes

```{r}
library(tidyverse)
load(url("https://github.com/fhdsl/S1_Intro_to_R/raw/main/classroom_data/CCLE.RData"))
```

Recall what we did in class:

> In the dataframe you have here, which rows would you filter for and columns would you select that relate to a scientific question?

Formulate a new question for the dataset, this time using a compound comparison operation in the filter step. Do this in two ways similar to before: Method 1 is to store your dataframe as a variable after you use `filter()`, and another dataframe variable after you `select()`. Method 2 is to do this all in one line, in which the returned dataframe of `filter()` is used for the argument of `select()`.

Your scientific question:

Filter: Myeloid cancers,

Select: treatment and growth pattern

Method 1:

```{r}
metadata_filtered = filter(metadata, OncotreeLineage == "Myeloid")
myeloid_metadata = select(metadata_filtered, ModelID, TreatmentStatus, GrowthPattern)
```

Method 2:

```{r}

result = select(filter(metadata, OncotreeLineage == "Myeloid"), ModelID, TreatmentStatus, GrowthPattern)
```

Let's check that Method 1 and 2 are doing the same thing. Run `ncol()` and `nrow()` to compare, and any other useful functions you think of.

```{r}

nrow(myeloid_metadata)
ncol(myeloid_metadata)

nrow(result)
ncol(result)
```

## Optional: Summary statistics

If the columns of interest are numeric, then you can try functions such as `mean()`, `median()`, `mode()`, or `summary()`. If the columns of interest is character or logical, then you can try the `table()` function.

All of these functions take in a vector as input and not a dataframe, so you have to access the column as a vector via the `$` operation.

## Feedback!

How many hours did you spend on this exercise?

```{r}
time_spent = 0 
```

If you worked with other peers, write their names down in the following character vector: each element is one person's name.

```{r}
peers = c("myself")
```
